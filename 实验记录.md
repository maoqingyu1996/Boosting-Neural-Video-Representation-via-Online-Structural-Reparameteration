# 实验记录-RepNeRV
## 介绍
在PRCV2025 RepNeRV代码上进行了重写，训练代码只要在main_train.py中运行即可。剪枝、量化、输出和测试代码都在main_eval.py中运行。

## TODO List
* [x] 将NeRV的训练代码迁移到main_train.py中
+ [x] 完成RepNeRV的测试代码
* [ ] 优化测试代码

### 1.1 视频表示任务-训练
在NeRV_vanilla分支时的运行代码，运行文件为``` main_train.py```，可以通过修改MLP层的参数来改变模型的大小。
```
CUDA_VISIBLE_DEVICES=0 python main_train.py \
    -e 300 --lower_width 96 --num_blocks 1 --dataset bunny --frame_gap 1 \
    --embed 1.25_40 --stem_dim_num 512_1 --reduction 2 --fc_hw_dim 9_16_26 \
    --expansion 1 --single_res --loss Fusion6 --warmup 0.2 --lr_type cosine \
    --strides 5 2 2 2 2 --conv_type conv -b 1 --lr 0.0005 --norm none --act swish \
    --outf bunny_nerv_300 --branch_type NeRV_vanilla
```
在ERB分支时的运行代码，可以通过修改MLP层的参数来改变模型的大小。
```
CUDA_VISIBLE_DEVICES=0 python main_train.py \
    -e 300 --lower_width 96 --num_blocks 1 --dataset bunny --frame_gap 1 \
    --embed 1.25_40 --stem_dim_num 512_1 --reduction 2 --fc_hw_dim 9_16_26 \
    --expansion 1 --single_res --loss Fusion6 --warmup 0.2 --lr_type cosine \
    --strides 5 2 2 2 2 --conv_type conv -b 1 --lr 0.0005 --norm none --act swish \
    --outf bunny_erb_300 --branch_type ERB
```
### 1.2 视频表示任务-剪枝量化输出
使用之前预训练的模型bunny_nerv_300进行剪枝量化输出,运行文件为``` main_eval.py```，自动读取最新模型，输出剪枝量化后模型的测试结果，包含FPS、平均PSNR、平均MS-SSIM、平均FPS。输出图像放置在bunny_nerv_300/visualize目录下。```--dump_images```,``` --prunt_ratio```和```--quant_bit``` 均为可选项。
```
CUDA_VISIBLE_DEVICES=0 python main_eval.py \
    -e 300 --lower_width 96 --num_blocks 1 --dataset bunny --frame_gap 1 \
    --embed 1.25_40 --stem_dim_num 512_1 --reduction 2 --fc_hw_dim 9_16_26 \
    --expansion 1 --single_res --loss Fusion6 --warmup 0.2 --lr_type cosine \
    --strides 5 2 2 2 2 --conv_type conv -b 1 --lr 0.0005 --norm none --act swish \
    --outf bunny_nerv_300 --branch_type NeRV_vanilla --prune_ratio 0.2 --quant_bit 8 
```
使用之前预训练的模型bunny_erb_300进行剪枝量化输出，自动读取最新模型，输出剪枝量化后模型的测试结果，包含FPS、平均PSNR、平均MS-SSIM、平均FPS。输出图像放置在bunny_erb_300/visualize目录下。

```
CUDA_VISIBLE_DEVICES=0 python main_eval.py \
    -e 300 --lower_width 96 --num_blocks 1 --dataset bunny --frame_gap 1 \
    --embed 1.25_40 --stem_dim_num 512_1 --reduction 2 --fc_hw_dim 9_16_26 \
    --expansion 1 --single_res --loss Fusion6 --warmup 0.2 --lr_type cosine \
    --strides 5 2 2 2 2 --conv_type conv -b 1 --lr 0.0005 --norm none --act swish \
    --outf bunny_erb_300 --branch_type ERB --prune_ratio 0.2 --quant_bit 8  --dump_images
```

### 1.3 视频表示任务-剪枝“微调”量化输出
使用之前预训练的模型bunny_nerv_300先进行剪枝微调，然后进行量化输出，自动读取最新模型，输出剪枝量化后模型的测试结果，包含FPS、平均PSNR、平均MS-SSIM、平均FPS。输出图像放置在bunny_nerv_300/visualize目录下。``` --funtune ```和``` --finetune_epochs```均为可选项，```--finetune_epochs``` 默认为100.
```
CUDA_VISIBLE_DEVICES=0 python main_eval.py \
    -e 300 --lower_width 96 --num_blocks 1 --dataset bunny --frame_gap 1 \
    --embed 1.25_40 --stem_dim_num 512_1 --reduction 2 --fc_hw_dim 9_16_26 \
    --expansion 1 --single_res --loss Fusion6 --warmup 0.2 --lr_type cosine \
    --strides 5 2 2 2 2 --conv_type conv -b 1 --lr 0.0005 --norm none --act swish \
    --outf bunny_nerv_300 --branch_type NeRV_vanilla --prune_ratio 0.2 --quant_bit 8  --dump_images \
    --finetune --finetune_epochs 10 
```
使用之前预训练的模型bunny_erb_300先进行剪枝微调，然后进行量化输出。重参化模型是在训练态进行剪枝微调，因此自动读取最新模型，输出剪枝量化后模型的测试结果，包含FPS、平均PSNR、平均MS-SSIM、平均FPS。输出图像放置在bunny_erb_300/visualize目录下。

```
CUDA_VISIBLE_DEVICES=0 python main_eval.py \
    -e 300 --lower_width 96 --num_blocks 1 --dataset bunny --frame_gap 1 \
    --embed 1.25_40 --stem_dim_num 512_1 --reduction 2 --fc_hw_dim 9_16_26 \
    --expansion 1 --single_res --loss Fusion6 --warmup 0.2 --lr_type cosine \
    --strides 5 2 2 2 2 --conv_type conv -b 1 --lr 0.0005 --norm none --act swish \
    --outf bunny_erb_300 --branch_type ERB --prune_ratio 0.2 --quant_bit 8  --dump_images \
    --finetune --finetune_epochs 10 
```